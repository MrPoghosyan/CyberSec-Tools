# Time-of-Check to Time-of-Use (TOCTOU) խոցելիություն execl() կանչի դեպքում

Այս պահոցը ցույց է տալիս դասական TOCTOU մրցավազքի (race condition) խոցելիություն, երբ ծրագիրն առաջում ստուգում է ֆայլը, իսկ հետո՝ որոշ ժամանակ անց, գործարկում է այն ըստ ուղու (execl(path, ...)). Ստեղն այն է, որ միջակայքում հարձակվողը կարող է փոխարինել կամ վերագրել ֆայլը, և վերջում կգործարկվի արդեն այլ բինարը։

Ցուցադրական սցենար

Ունենք երեք ֆայլ.

main.c — ստուգում է «մուտքային» բինարի checksum–ը, հետո sleep() է անում և գործարկում է ֆայլը ուղիով (execl(argv[1], ...)).

good_program.c — «լավ» ծրագիր։

evil_program.c — «վատ» ծրագիր։

Ստորև բերված կոդը օգտագործվում է հենց այս ցուցադրության համար (main.c).

Նշում. checksum-ը պարզապես բայթերի գումարն է՝ դիտավորյալ թույլ մեթոդ՝ ցուցադրության պարզության համար։

## Կառուցում և վերարտադրություն`
# Կոմպիլյացիա (bash comand)
gcc -O2 -o check_program main.c
gcc -O2 -o good_program good_program.c
gcc -O2 -o evil_program evil_program.c
Այստեղ՝
    gcc → կոմպիլյատոր,
    -O2 → օպտիմիզացիայի մակարդակ (ընտրված է balance արագության ու չափի համար),
    -o check_program → վերջնական բինարի անունը կլինի check_program,
    main.c → կոդի ֆայլը։

# Սկզբնական «input» բինարը դարձնենք «լավը»
cp good_program input

# Գործարկենք ստուգողը
./check_program input
# Այս պահին ծրագիրը կհաշվի checksum, կհամեմատի, հետո կքնի ~11 վայրկյան։
# Մինչ քնած է, փոխարինում ենք input-ը.
rm input && cp evil_program input

# Քունը ավարտվելուց հետո check_program-ը կանչում է execl("input", ...)
# և կգործարկվի արդեն EVIL ծրագիրը։

Ինչու՞ է աշխատում հարձակումը. ստուգումն արվում է նախքան sleep()–ը և անձայն վստահվում է, որ ֆայլը չի փոխվի մինչև execl(). Սակայն execl()–ը կրկին բացում է ֆայլը ուղիով (path), և մենք արդեն այդ ուղու տակ այլ բինար ենք դրել։

## Լուծում 1 (ոչ լիարժեք) — գործարկել ֆայլով not path: fexecve()

Մի ինտուիտիվ մեղմացում է՝ բացել ֆայլը և հետո գործարկել նույն ֆայլային դիսկրիպտորով՝ fexecve(fd, argv, envp)։ Այսպիսով, նույնիսկ եթե հարձակվողը անի rm input && cp evil_program input, ձեր բացված fd–ն կմնա հին inode–ին կպած, և կգործարկվի ճիշտ բինարը։

Սակայն սահմանափակում. Եթե հարձակվողը չջնջի ֆայլը, այլ ուղղակի վերագրի բովանդակությունը նույն inode–ում (օրինակ՝ cp evil_program input որոշ դեպքերում կարող է վերագրել տեղում), ապա նույն fd–ով կկարդաք արդեն փոփոխված բովանդակություն, և fexecve()–ն էլ կգործարկի այդ փոփոխված բինարը։ Δηλαδή fexecve()–ն լուծում է «փոխարինման» (rename/unlink) վեկտորը, բայց ոչ «տեղում վերագրելու» (in-place overwrite) վեկտորը։

Կարճ սքեմա (պսևդոկոդ).
int fd = open(path, O_PATH /* կամ հարմար դրոշակներով */);
if (fd < 0) ...;
// optionally compute checksum via another read handle or by reopening read-only same inode
// ...
fexecve(fd, (char*[]){path, NULL}, environ);

## Ավելի ամուր մոտեցում — «ստուգել և նույնը գործարկել» առանց path վերադարձի`

Ստույգ գաղափարը՝

Բացել գործարկվելիք ֆայլը և միայն այդ նույն բացված ֆայլով իրականացնել հետագա բոլոր գործողությունները (կարդալ, checksum, մետատվյալների ստուգումներ, և վերջում՝ fexecve)։

ՈՉԵՆՔ նորից հղվում ուղուն մինչև գործարկումը։

Բարձրացնող միջոցներ՝

Մետատվյալների ստուգում: fstat(fd) → ստուգել, որ

st_uid/st_gid վստահելի են (օր.՝ root կամ ընթացիկ օգտատերը),

թույլտվությունները «սուր» չեն (ոչ world-writable, ոչ setuid անակնկալով),

S_ISREG(st_mode); արգելել սիմվոլիկ հղումները՝ բացել O_NOFOLLOW–ով (կամ բացել openat2–ով կոշտ քաղաքականությամբ)։

Checksum/Hash նույն fd–ից (pread) և անմիջապես հետո fexecve(fd, ...)՝ առանց ժամանակ տալու միջանկյալ փոփոխության։

Ցուցիչ՝ օգտագործել ուժեղ hash (օր.՝ SHA-256), ոչ թե պարզ գումար։

Բացման դրոշակներ (Linux):

O_NOFOLLOW — չհետևել symlink–ներին,

O_CLOEXEC — փակել fd–ն երեխաներում, եթե չենք օգտագործում fexecve,

հնարավորության դեպքում openat2()՝ RESOLVE_BENEATH, RESOLVE_NO_SYMLINKS։

Թույլտվությունները/Սեփականատերը՝ արգելել գործարկումը, եթե ֆայլը writable է այլոց կողմից (օր. st_mode & (S_IWGRP|S_IWOTH)), կամ եթե ճանապարհը գտնվում է writable դիրեկտորիայում, որը վերահսկում է չվստահելի կողմը։

Ամբողջականության քաղաքականություն (առավել ուժեղ):

Թվային ստորագրում (Detached signature) և հաստատում՝ exec-ից անմիջապես առաջ,

Ֆայլային համակարգի մակարդակի վերիվարման տեխնոլոգիաներ՝ fs-verity, dm-verity։

Գաղափարային օրինակ (պսևդոկոդ)``
int exec_fd = openat(AT_FDCWD, argv[1],
                     O_RDONLY | O_NOFOLLOW /* + openat2 policy if available */);
if (exec_fd < 0) fail();

// 1) fstat(exec_fd) -> verify owner/perms/mode
// 2) strong_hash(exec_fd) -> verify expected digest (e.g. from trusted store)
// 3) (optional) lseek(exec_fd, 0, SEEK_SET);

// 4) Execute the very same opened file:
fexecve(exec_fd, (char * const[]){ argv[1], NULL }, environ);
perror("fexecve");
Կարևորը՝ չէք վերադառնում path–ին ստուգումից հետո։ Գործարկվում է հենց այն, ինչ ստուգվել է։

Լավ պրակտիկայի կարճ ցուցակ`
Բացիր գործարկվելիք ֆայլը մեկ անգամ, ստուգիր նույն fd–ով, գործարկիր fexecve(fd, ...)։
Օգտագործիր O_NOFOLLOW, արգելիր world-writable ուղիները։
Վերահաստատիր սեփականատեր/թույլտվություններ (fstat)։
Օգտագործիր ուժեղ hash (SHA-256) կամ թվային ստորագրում։
Մի կառուցիր լոգիկան այնպես, որ ստուգումից հետո ժամանակ անցնի exec–ից առաջ (անջատիր race window–ը)։
Կարող ես կիրառել seccomp/pledge–անման sandbox exec–ից հետո՝ նվազեցնելու վնասը նույնիսկ հաջող հարձակման դեպքում։
